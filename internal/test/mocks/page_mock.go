// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/go-rod/rod/lib/input"
	mock "github.com/stretchr/testify/mock"
	"github.com/vo1dFl0w/marketplace-parser-service/internal/repository"
)

// NewPageMock creates a new instance of PageMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPageMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *PageMock {
	mock := &PageMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PageMock is an autogenerated mock type for the Page type
type PageMock struct {
	mock.Mock
}

type PageMock_Expecter struct {
	mock *mock.Mock
}

func (_m *PageMock) EXPECT() *PageMock_Expecter {
	return &PageMock_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type PageMock
func (_mock *PageMock) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PageMock_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type PageMock_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *PageMock_Expecter) Close() *PageMock_Close_Call {
	return &PageMock_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *PageMock_Close_Call) Run(run func()) *PageMock_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PageMock_Close_Call) Return(err error) *PageMock_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PageMock_Close_Call) RunAndReturn(run func() error) *PageMock_Close_Call {
	_c.Call.Return(run)
	return _c
}

// ClosePopUpWindow provides a mock function for the type PageMock
func (_mock *PageMock) ClosePopUpWindow(ctx context.Context, selector string) error {
	ret := _mock.Called(ctx, selector)

	if len(ret) == 0 {
		panic("no return value specified for ClosePopUpWindow")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, selector)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PageMock_ClosePopUpWindow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClosePopUpWindow'
type PageMock_ClosePopUpWindow_Call struct {
	*mock.Call
}

// ClosePopUpWindow is a helper method to define mock.On call
//   - ctx context.Context
//   - selector string
func (_e *PageMock_Expecter) ClosePopUpWindow(ctx interface{}, selector interface{}) *PageMock_ClosePopUpWindow_Call {
	return &PageMock_ClosePopUpWindow_Call{Call: _e.mock.On("ClosePopUpWindow", ctx, selector)}
}

func (_c *PageMock_ClosePopUpWindow_Call) Run(run func(ctx context.Context, selector string)) *PageMock_ClosePopUpWindow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PageMock_ClosePopUpWindow_Call) Return(err error) *PageMock_ClosePopUpWindow_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PageMock_ClosePopUpWindow_Call) RunAndReturn(run func(ctx context.Context, selector string) error) *PageMock_ClosePopUpWindow_Call {
	_c.Call.Return(run)
	return _c
}

// Element provides a mock function for the type PageMock
func (_mock *PageMock) Element(ctx context.Context, selector string) (repository.Element, error) {
	ret := _mock.Called(ctx, selector)

	if len(ret) == 0 {
		panic("no return value specified for Element")
	}

	var r0 repository.Element
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (repository.Element, error)); ok {
		return returnFunc(ctx, selector)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) repository.Element); ok {
		r0 = returnFunc(ctx, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.Element)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, selector)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PageMock_Element_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Element'
type PageMock_Element_Call struct {
	*mock.Call
}

// Element is a helper method to define mock.On call
//   - ctx context.Context
//   - selector string
func (_e *PageMock_Expecter) Element(ctx interface{}, selector interface{}) *PageMock_Element_Call {
	return &PageMock_Element_Call{Call: _e.mock.On("Element", ctx, selector)}
}

func (_c *PageMock_Element_Call) Run(run func(ctx context.Context, selector string)) *PageMock_Element_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PageMock_Element_Call) Return(element repository.Element, err error) *PageMock_Element_Call {
	_c.Call.Return(element, err)
	return _c
}

func (_c *PageMock_Element_Call) RunAndReturn(run func(ctx context.Context, selector string) (repository.Element, error)) *PageMock_Element_Call {
	_c.Call.Return(run)
	return _c
}

// Elements provides a mock function for the type PageMock
func (_mock *PageMock) Elements(ctx context.Context, selector string) ([]repository.Element, error) {
	ret := _mock.Called(ctx, selector)

	if len(ret) == 0 {
		panic("no return value specified for Elements")
	}

	var r0 []repository.Element
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]repository.Element, error)); ok {
		return returnFunc(ctx, selector)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []repository.Element); ok {
		r0 = returnFunc(ctx, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.Element)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, selector)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PageMock_Elements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Elements'
type PageMock_Elements_Call struct {
	*mock.Call
}

// Elements is a helper method to define mock.On call
//   - ctx context.Context
//   - selector string
func (_e *PageMock_Expecter) Elements(ctx interface{}, selector interface{}) *PageMock_Elements_Call {
	return &PageMock_Elements_Call{Call: _e.mock.On("Elements", ctx, selector)}
}

func (_c *PageMock_Elements_Call) Run(run func(ctx context.Context, selector string)) *PageMock_Elements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PageMock_Elements_Call) Return(elements []repository.Element, err error) *PageMock_Elements_Call {
	_c.Call.Return(elements, err)
	return _c
}

func (_c *PageMock_Elements_Call) RunAndReturn(run func(ctx context.Context, selector string) ([]repository.Element, error)) *PageMock_Elements_Call {
	_c.Call.Return(run)
	return _c
}

// KeyboardType provides a mock function for the type PageMock
func (_mock *PageMock) KeyboardType(ctx context.Context, key input.Key) error {
	ret := _mock.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for KeyboardType")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, input.Key) error); ok {
		r0 = returnFunc(ctx, key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PageMock_KeyboardType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyboardType'
type PageMock_KeyboardType_Call struct {
	*mock.Call
}

// KeyboardType is a helper method to define mock.On call
//   - ctx context.Context
//   - key input.Key
func (_e *PageMock_Expecter) KeyboardType(ctx interface{}, key interface{}) *PageMock_KeyboardType_Call {
	return &PageMock_KeyboardType_Call{Call: _e.mock.On("KeyboardType", ctx, key)}
}

func (_c *PageMock_KeyboardType_Call) Run(run func(ctx context.Context, key input.Key)) *PageMock_KeyboardType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 input.Key
		if args[1] != nil {
			arg1 = args[1].(input.Key)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PageMock_KeyboardType_Call) Return(err error) *PageMock_KeyboardType_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PageMock_KeyboardType_Call) RunAndReturn(run func(ctx context.Context, key input.Key) error) *PageMock_KeyboardType_Call {
	_c.Call.Return(run)
	return _c
}

// MoveCursorToElement provides a mock function for the type PageMock
func (_mock *PageMock) MoveCursorToElement(ctx context.Context, elemName string) error {
	ret := _mock.Called(ctx, elemName)

	if len(ret) == 0 {
		panic("no return value specified for MoveCursorToElement")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, elemName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PageMock_MoveCursorToElement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MoveCursorToElement'
type PageMock_MoveCursorToElement_Call struct {
	*mock.Call
}

// MoveCursorToElement is a helper method to define mock.On call
//   - ctx context.Context
//   - elemName string
func (_e *PageMock_Expecter) MoveCursorToElement(ctx interface{}, elemName interface{}) *PageMock_MoveCursorToElement_Call {
	return &PageMock_MoveCursorToElement_Call{Call: _e.mock.On("MoveCursorToElement", ctx, elemName)}
}

func (_c *PageMock_MoveCursorToElement_Call) Run(run func(ctx context.Context, elemName string)) *PageMock_MoveCursorToElement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PageMock_MoveCursorToElement_Call) Return(err error) *PageMock_MoveCursorToElement_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PageMock_MoveCursorToElement_Call) RunAndReturn(run func(ctx context.Context, elemName string) error) *PageMock_MoveCursorToElement_Call {
	_c.Call.Return(run)
	return _c
}

// NavigateWithReferer provides a mock function for the type PageMock
func (_mock *PageMock) NavigateWithReferer(ctx context.Context, url string) error {
	ret := _mock.Called(ctx, url)

	if len(ret) == 0 {
		panic("no return value specified for NavigateWithReferer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, url)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PageMock_NavigateWithReferer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NavigateWithReferer'
type PageMock_NavigateWithReferer_Call struct {
	*mock.Call
}

// NavigateWithReferer is a helper method to define mock.On call
//   - ctx context.Context
//   - url string
func (_e *PageMock_Expecter) NavigateWithReferer(ctx interface{}, url interface{}) *PageMock_NavigateWithReferer_Call {
	return &PageMock_NavigateWithReferer_Call{Call: _e.mock.On("NavigateWithReferer", ctx, url)}
}

func (_c *PageMock_NavigateWithReferer_Call) Run(run func(ctx context.Context, url string)) *PageMock_NavigateWithReferer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PageMock_NavigateWithReferer_Call) Return(err error) *PageMock_NavigateWithReferer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PageMock_NavigateWithReferer_Call) RunAndReturn(run func(ctx context.Context, url string) error) *PageMock_NavigateWithReferer_Call {
	_c.Call.Return(run)
	return _c
}

// WaitDOMStable provides a mock function for the type PageMock
func (_mock *PageMock) WaitDOMStable(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WaitDOMStable")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PageMock_WaitDOMStable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitDOMStable'
type PageMock_WaitDOMStable_Call struct {
	*mock.Call
}

// WaitDOMStable is a helper method to define mock.On call
//   - ctx context.Context
func (_e *PageMock_Expecter) WaitDOMStable(ctx interface{}) *PageMock_WaitDOMStable_Call {
	return &PageMock_WaitDOMStable_Call{Call: _e.mock.On("WaitDOMStable", ctx)}
}

func (_c *PageMock_WaitDOMStable_Call) Run(run func(ctx context.Context)) *PageMock_WaitDOMStable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PageMock_WaitDOMStable_Call) Return(err error) *PageMock_WaitDOMStable_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PageMock_WaitDOMStable_Call) RunAndReturn(run func(ctx context.Context) error) *PageMock_WaitDOMStable_Call {
	_c.Call.Return(run)
	return _c
}
